WITH parent AS (
  SELECT
    bucket_name,
    file_path AS original_path
  FROM `project.dataset.parent_logs`
),
resolved AS (
  SELECT
    bucket_name,
    resolved_path
  FROM `project.dataset.resolved_paths`
)

SELECT
  p.bucket_name,
  p.original_path,
  r.resolved_path
FROM parent p
JOIN resolved r
  ON p.bucket_name = r.bucket_name
 AND REGEXP_REPLACE(
       p.original_path,
       r'YYYYMMDD|yyyyMMdd|YYYYMM|yyyyMM|YYYY|yyyy|YY|yy|MM|mm|DD|dd',
       ''
     ) = REGEXP_REPLACE(
       r.resolved_path,
       r'[0-9]{8}|[0-9]{6}|[0-9]{4}|[0-9]{2}',
       ''
     );


#####
import re
from datetime import datetime

def resolve_date_path(file_path: str, target_date: datetime = None) -> str:
    """
    Replace date placeholders safely, avoiding replacements embedded within alphabetic words.
    Supports both uppercase and lowercase tokens:
      YYYY, YY, MM, DD
      yyyy, yy, mm, dd
    Also supports combined tokens like YYYYMMDD or yyyymmdd.
    """
    if target_date is None:
        target_date = datetime.now()

    # Replacement tokens ordered longest-first
    replacements = [
        ("YYYYMMDD", target_date.strftime("%Y%m%d")),
        ("YYYYMM",   target_date.strftime("%Y%m")),
        ("YYYY",     target_date.strftime("%Y")),
        ("YY",       target_date.strftime("%y")),
        ("MM",       target_date.strftime("%m")),
        ("DD",       target_date.strftime("%d")),

        ("yyyyMMdd", target_date.strftime("%Y%m%d")),  # lowercase full
        ("yyyyMM",   target_date.strftime("%Y%m")),
        ("yyyy",     target_date.strftime("%Y")),
        ("yy",       target_date.strftime("%y")),
        ("mm",       target_date.strftime("%m")),
        ("dd",       target_date.strftime("%d")),
    ]

    result = file_path
    for placeholder, replacement in replacements:
        # negative lookbehind/lookahead for alphabetic characters only
        # ensures tokens inside words like COMMUNICATION won't be replaced
        pattern = rf"(?<![A-Za-z]){re.escape(placeholder)}(?![A-Za-z])"
        result = re.sub(pattern, replacement, result)

    return result


------
import re
from datetime import datetime

def resolve_date_path(file_path, target_date=None):
    """
    Safely resolve date placeholders (YYYY, YY, MM, DD, YYYYMM, YYYYMMDD)
    in a file path without replacing random substrings like 'COMMUNICATION'.
    """
    if target_date is None:
        target_date = datetime.now()

    # Ordered longest → shortest to avoid partial replacements
    format_replacements = [
        (r'YYYYMMDD', target_date.strftime('%Y%m%d')),
        (r'YYYYMM', target_date.strftime('%Y%m')),
        (r'YYYY', target_date.strftime('%Y')),
        (r'YY', target_date.strftime('%y')),
        (r'MM', target_date.strftime('%m')),
        (r'DD', target_date.strftime('%d'))
    ]

    # Replace only when they appear as clear tokens or sequences
    for pattern, replacement in format_replacements:
        file_path = re.sub(pattern, replacement, file_path)

    return file_path

TEST_DATE = datetime(2023, 11, 15)

print(resolve_date_path("data/YYYY/file.json", TEST_DATE))    
# → data/2023/file.json

print(resolve_date_path("logs/YYYYMM/app.log", TEST_DATE))   
# → logs/202311/app.log

print(resolve_date_path("exports/YYYYMMDD/data.csv", TEST_DATE))   
# → exports/20231115/data.csv

print(resolve_date_path("archive/YYYY/MM/DD/backup.zip", TEST_DATE))   
# → archive/2023/11/15/backup.zip

print(resolve_date_path("COMMUNICATION_test.txt", TEST_DATE))   
# → COMMUNICATION_test.txt   ✅ untouched

print(resolve_date_path("X_YY_MM_DD_Y", TEST_DATE))  
# → X_23_11_15_Y

print(resolve_date_path("1YYYY2MM3DD4", TEST_DATE))  
# → 1202311154   ✅ fixed




#####
WITH parsed AS (
  SELECT
    resource.labels.bucket_name AS bucket_name,
    -- Extract file_name without generation number
    REGEXP_EXTRACT(protoPayload.resourceName, r'/objects/([^#]+)') AS file_name,
    timestamp AS create_ts
  FROM
    `project.gcs_logs.cloudaudit_googleapis_com_data_access`
  WHERE
    protoPayload.methodName = "storage.objects.create"
    AND protoPayload.resourceName IS NOT NULL
)

SELECT
  bucket_name,
  create_date,
  COUNT(1) AS unique_file_count_first_seen
FROM (
  SELECT
    bucket_name,
    file_name,
    DATE(create_ts) AS create_date,
    ROW_NUMBER() OVER (
      PARTITION BY bucket_name, file_name
      ORDER BY create_ts
    ) AS rn
  FROM parsed
  WHERE file_name IS NOT NULL
)
WHERE rn = 1
GROUP BY bucket_name, create_date
ORDER BY bucket_name, create_date;
